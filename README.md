- 为什么会切换到next.js
在我们之前项目, 几乎都是单页面应用, 此单页面初始化只有一个html, seo不友善, 
并且在我们做了路由切片以后，在跳转路由过程中, 总会有一个过渡动画, 不管我们是
使用loading动画还是其他方式，会给用户一种体验中断的既视感, 并且如果下一页面数据
需要等待接口返回，然后渲染。这种延迟感极为严重，这种情况如果我们支持SSR，就可以提前
在服务器生成相关dom元素, 返回给前端浏览器后，这种延迟感就不会那么严重

- 远程图像处理
next内置的图像服务，转化的url如下
> https://xx.com/_next/image?url=https%3A%2F%2Fxx1.com%2Ffile2%2F1%2C7020b7be0a&w=750&q=75

此方案在我们实际业务场景中发现, 不是所有的cdn都支持这种动态url的方式, 当然也可以使用三方的oss服务, 但是
基于三方稳定性，我们还是希望能在公司本身业务解决，所以通过一次路由反转将这种url转换为

> https://xx.com/optimize/image/w=750&q=75/https%3A%2F%2Fxx1.com%2Ffile2%2F1%2C7020b7be0a

在这种路径下，几乎cdn都能缓存, 相关代码在image-optimizer.rewrite.js

- 本地图像处理
内置的scss不支持url-loader, 官方推荐的next-image也不行, 所以我们选择三方的next-optimized-images, 其
canary版本支持本地静态转化, 但是其cache文件在node_modules下面, 每次yarn会重新清除, 不能持久化, 所以我们将
此文件移动到项目根目录, 但是它本身代码针对scss内置的图像处理有问题, 所以我们fork了他的代码, 并修改了相关配置
发布了新的包，注意，目前只支持next 11的版本，如果你要使用12以上版本，这个包目前是不兼容的

- 自定义server.js
因为项目中还涉及页面SSR缓存, 所以我们自定义的server，以方便扩展服务器方法，我们为服务器提供了SSR缓存, 默认为3分钟,
这种能减少node服务器渲染压力，相关代码在lru-cache.js

- pwa
项目支持使用server work缓存静态资源, 并且定制站点需要缓存的资源路由

- 项目结构
我们使用.page结尾，配合next内置的路由扫描, 提供路由处理, 这种方案配合我们代码分层结构。
内聚相关代码在当前文件夹
1. 统一使用小驼峰命名
2. 文件以ts/tsx结尾
3. 事件方法以on开头，
4. 回调 处理 以handle 开头
5. 获取数据以get开头
6. 如果render要拆分，方法以render开头
7. 页面分层，以最近优先级，将当前页面相关的代码放在一个文件夹，增加其高内聚，如果有业务代码，放置于当前模块，尽量不提到顶层方法库
   文件结构以树型分层，每个stack对应的模块内部，一个页面对应内部一个文件夹，
   不管是component，utils，config，constants，assets, 都遵循src顶层-> stack顶层 -> 页面层，以当前的通用的程度，决定文件层级位置，最近优先为原则
   构建组件采用容器和试图组件的设计模式，其他模式请参考 设计模式
8. 高阶组件默认使用hoc开头
9. 代码清洁，不需要的代码，请删除，如果当前代码确定可能后续需要使用，请标注说明

